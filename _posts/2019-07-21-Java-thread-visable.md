---
layout: post
title:  "Java多线程之内存可见性"
date:   2019-07-17 20:14:54
categories: java
tags: java 内存可见性 多线程
---

* content
{:toc}

# Java多线程之内存可见性
## 概念:
#### 可见性:
一个线程对共享变量值的修改，能够及时的被其它线程看到。  
#### 共享变量:
如果一个变量在多个线程中都有工作副本，那么这个变量就是这几个线程的共享变量。
#### Java内存模型（JMM）
`Java`内存模型（`Java Memory Model`）描述了`Java`程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。
* 所有的变量都存储在主内存中  
* 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（`主内存中该变量的一份拷贝`)  
* 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写  
* 不同线程之间无法直接访问其它线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成

#### 指令重排序
代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化
* 编译器优化的重排序（编译器优化）
* 指令级并行重排序（处理器优化）
* 内存系统的重排序（处理器优化）

`as-if-serial`: 无论如何重排序，程序执行的结果应该与代码顺序执行结果一致（`Java`编译器，运行时和处理器都会保证`Java`在单线程下遵循`as-if-serial`语义)  
`注：重排序不会给单线程带来内存可见性问题，多线程中程序交错执行时，重排序可能会造成内存可见性问题`

## 共享变量可见性实现的原理
线程`1`对共享变量的修改想要被线程`2`及时看到，必须要经过如下`2`个步骤：  
* 把工作内存`1`中更新过的共享变量刷新到主内存中
* 将主内存中最新的共享变量的值更新到工作内存`2`中  

## 实现共享变量的可见性
* 线程修改后的共享变量值能够及时从工作内存刷新到主内存中  
* 其它线程能及时把共享变量的最新值从主内存更新到自己的工作内存中

## 导致共享变量在线程之间不可见的原因
* 线程的交叉执行
* 重排序结合线程交叉执行
* 共享变量更新后的值没有在工作内存与主内存间及时更新

## Java中实现可见性的方式
* `synchronized`  
 * 原子性（同步）
 * 可见性  

   ###### `JMM`关于`synchronized`的两条规定:
   * 线程解锁前，必须把共享变量的最新赋值刷新大澳主内存中
   * 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（`注意：加锁与解锁需要是同一把锁`)  
线程解锁前对共享变量的修改在下次加锁时对其它线程可见  

   ###### 线程执行互斥代码的过程
   * 获得互斥锁
   * 清空工作区内存
   * 从主内存拷贝变量的最新副本到工作内存
   * 执行代码
   * 将更改后的共享变量的值刷新到主内存
   * 释放互斥锁   

   ###### 解决方案
   * 线程锁提供了原子性，解决来线程的交叉执行，无论怎么重排序都是在一个锁块区域内和单线程执行没什么区别
   * 可见性在线程解锁时会把共享变量的值刷新到主内存中
* `volatile`
  * 能够保证`volatile`变量的可见性
  * 不能保证`volatile`变量复合操作的原子性  

   ###### `volatile` 如何实现内存可见性
   深入来说：通过加入内存屏障和禁止重排序优化来实现的
   * 对`volatile`变量执行写操作时，会在写操作后加入一条`store`屏障指令
   * 对`volatile`变量执行读操作时，会在读操作前加入一条`load`屏障指令  

   通俗的说：`volatile`变量在每次被线程访问时，都强迫从主内存中重新读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。
  ###### 线程写`volatile`变量的过程
   * 改变线程工作内存中`volatile`变量副本的值
   * 将改变后的副本的值从工作内存刷新到主内存

   ###### 线程读`volatile`变量的过程
   * 从主内存中读取`volatile`变量的最新值到线程的工作内存中
   * 从工作内存中读取`volatile`变量的副本

   ###### `volatile`不能保证`volatile`变量复合操作的原子性
   ```
   private int number = 0;
   number ++; //不是原子操作
   ```
   * 读取number的值
   * 将number的值加1
   * 写入最新的number的值

   ```
   synchronized(this) {
     number++;
   }
   ```
   上述代码能保证原子性，属于原子操作
   ```
   private volatile int number = 0;
   ```
   上述代码添加`volatile`字段，也无法保证原子性

   ###### `volatile`不能保证原子性分析
   ```
   number++ // 上面说了这步操作实际上分三步执行
   ```
   number = 5  
   1.线程A读取number的值  
   2.线程B读取number的值  
   3.线程B执行加1操作  
   4.线程B写入最新的number的值  
   主内存：`number = 6`  
   线程B工作内存：`number = 6`  
   线程A工作内存：`number = 5`  
   5.线程A执行加1操作  
   6.线程A写入最新的`number`值
   结果：两个线程分别进行了加1，但是结果总共才增加1

   ###### 保证`number`自增操作的原子性
   * 使用`synchronized`关键字  
   在自增操作的地方用，尽量缩小范围
   * `JDK1.5`以后提供的`ReentrantLock`(`java.until.concurrent.locks`包下)  
   ```
   private Lock lock = new ReentrantLock();
   lock.lock();
   try {
     number++;
   } finally {
     lock.unlock();
   }
   ```
   * 使用`AtomicInterger`（`vava.util.concurrent.atomic`包下）  

   ###### `volatile`使用场合
   要在多线程中安全使用`volatile`变量，必须同时满足：  
   1.对变量的写入操作不依赖其当前值
   * 不满足：`number++`, `count = count * 5`等
   * 满足：boolean变量，纪录温度变化的变量等
   2.该变量没有包含在具有其它变量的不变式中

## `synchronized`和`voaltile`比较
* `volatile`不需要加锁，比`synchronized`更轻量级，不会阻塞线程；
* 从内存可见性角度讲，`volatile`读相当于加锁，`volatile`写相当于解锁
* `synchronized`既能保证可见性，又能保证原子性，而`volatile`只能保证可见性，无法保证原子性
