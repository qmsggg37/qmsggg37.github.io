---
layout: post
title:  "Java内存模型FAQ（三）JSR133是什么?"
date:   2019-07-17 20:14:54
categories: java
tags: java JSR133
---

* content
{:toc}

# `Java`内存模型`FAQ`（`三`）`JSR133`是什么?
[原文](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html )第三章
从`1997`年以来，人们不断发现`Java`语言规范的`17`章定义的`Java`内存模型中的一些严重的缺陷。这些缺陷会导致一些使人迷惑的行为（例如`final`字段会被观察到值的改变）和破坏编译器常见的优化能力。

`Java`内存模型是一个雄心勃勃的计划，它是编程语言规范第一次尝试合并一个能够在各种处理器架构中为并发提供一致语义的内存模型。不过，定义一个既一致又直观的内存模型远比想象要更难。`JSR133`为`Java`语言定义了一个新的内存模型，它修复了早期内存模型中的缺陷。为了实现`JSR133`，`final`和`volatile`的语义需要重新定义。

[完整的语义见](http://www.cs.umd.edu/users/pugh/java/memoryModel)，但是正式的语义不是小心翼翼的，它是令人惊讶和清醒的，目的是让人意识到一些看似简单的概念（如同步）其实有多复杂。幸运的是，你不需要懂得这些正式语义的细节——`JSR133`的目的是创建一组正式语义，这些正式语义提供了`volatile`、`synchronzied`和`final如`何工作的直观框架。

`JSR 133`的目标包含了：

保留已经存在的安全保证（像类型安全）以及强化其他的安全保证。例如，变量值不能凭空创建：线程观察到的每个变量的值必须是被其他线程合理的设置的。
正确同步的程序的语义应该尽量简单和直观。
应该定义未完成或者未正确同步的程序的语义，主要是为了把潜在的安全危害降到最低。
程序员应该能够自信的推断多线程程序如何同内存进行交互的。
能够在现在许多流行的硬件架构中设计正确以及高性能的`JVM`实现。
应该能提供 安全地初始化的保证。如果一个对象正确的构建了（意思是它的引用没有在构建的时候逸出，那么所有能够看到这个对象的引用的线程，在不进行同步的情况下，也将能看到在构造方法中中设置的`final`字段的值。
应该尽量不影响现有的代码。
